FIX_THIS.txt — Replit Fix Plan (MCC Console Errors)
Date: 2026-01-26
Goal: Fix Supabase PGRST201, /api 401 Unauthorized, Supabase 404/400/406, and (optional) CSP source-map warnings.

============================================================
0) RULE #1 (IMPORTANT): DO NOT PASTE JAVASCRIPT INTO SUPABASE SQL
============================================================
Supabase SQL Editor runs SQL only.
Anything like `import`, `const`, `await` belongs in Replit code files, not SQL.

============================================================
1) FIX: Supabase PGRST201 (Ambiguous relationship embed)
============================================================
Error looks like:
PGRST201: Could not embed because more than one relationship was found for 'bids' and 'maintenance_packages'

This means your query has something like:
supabase.from('bids').select('*, maintenance_packages(*)')
…but Supabase sees more than one FK path and needs you to specify WHICH FK.

STEP 1.1 — Find the query in Replit
- Use Replit Search (Ctrl+F / Cmd+F across project):
  Search: from('bids')
  Search: maintenance_packages
  Search: "maintenance_packages(*)"
  Look in files like providers-bids.js / providers-core.js.

STEP 1.2 — Get the exact FK constraint name from Supabase
- Supabase Dashboard -> Database -> Table Editor
- Click table: bids
- Open Relationships / Foreign Keys
- Find relationship to maintenance_packages
- Copy the constraint name, e.g.:
  bids_maintenance_package_id_fkey
(Your name may differ — use EXACT.)

STEP 1.3 — Update your select to disambiguate
Replace:
  .select(`*, maintenance_packages(*)`)
With:
  .select(`*, maintenance_packages!YOUR_FK_NAME_HERE(*)`)

Example:
  .select(`*, maintenance_packages!bids_maintenance_package_id_fkey(*)`)

Restart app and refresh page. PGRST201 should be gone.

============================================================
2) FIX: /api/* endpoints returning 401 Unauthorized (Clover + POS)
============================================================
You have errors like:
GET /api/clover/status/... 401
GET /api/pos/connections/... 401

This must be fixed on BOTH sides:
A) Frontend must SEND a token
B) Backend must VERIFY the token

------------------------------------------------------------
2A) FRONTEND: Add apiFetch wrapper that sends Supabase access token
------------------------------------------------------------
STEP 2A.1 — Create a helper file in your frontend code area
Pick a location that your frontend can import from (examples):
- /public/js/apiFetch.js
- /src/apiFetch.js
- same folder as your supabaseClient.js

Paste:

----- BEGIN apiFetch.js -----
import { supabase } from "./supabaseClient.js"; // adjust path if needed

export async function apiFetch(path, options = {}) {
  const { data: { session } } = await supabase.auth.getSession();
  const token = session?.access_token;

  const headers = new Headers(options.headers || {});
  if (token) headers.set("Authorization", `Bearer ${token}`);

  // Only set JSON header if you actually send a body
  if (options.body && !headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json");
  }

  return fetch(path, { ...options, headers });
}
----- END apiFetch.js -----

STEP 2A.2 — Replace all direct fetch("/api/...") calls
Search in Replit:
  fetch("/api/
  fetch(`/api/
Replace patterns like:

BEFORE:
  fetch(`/api/clover/status/${providerId}`)

AFTER:
  apiFetch(`/api/clover/status/${providerId}`)

Do the same for:
- /api/pos/connections/...
- any other /api/... calls

------------------------------------------------------------
2B) BACKEND: Verify Authorization Bearer token in /api routes
------------------------------------------------------------
This assumes you have a Node server (Express-like) running in Replit.
If your project uses Next.js API routes or serverless, see section 2D.

STEP 2B.1 — Add Replit Secrets (Environment Variables)
In Replit -> Secrets (lock icon):
- SUPABASE_URL = https://xxxxx.supabase.co
- SUPABASE_SERVICE_ROLE_KEY = (service role key from Supabase)
IMPORTANT: Service role key is SERVER ONLY. Never expose to browser.

STEP 2B.2 — Install supabase-js on server
In Replit Shell:
  npm i @supabase/supabase-js

STEP 2B.3 — Create server middleware requireAuth.js
Create a file:
  /server/requireAuth.js
(or /src/server/requireAuth.js — wherever your server files live)

Paste:

----- BEGIN server/requireAuth.js -----
import { createClient } from "@supabase/supabase-js";

const supabaseAdmin = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

export async function requireAuth(req, res, next) {
  try {
    const auth = req.headers.authorization || "";
    const token = auth.startsWith("Bearer ") ? auth.slice(7) : null;

    if (!token) return res.status(401).json({ error: "Missing bearer token" });

    const { data, error } = await supabaseAdmin.auth.getUser(token);
    if (error || !data?.user) {
      return res.status(401).json({ error: "Invalid token" });
    }

    req.user = data.user;
    return next();
  } catch (e) {
    return res.status(401).json({ error: "Unauthorized" });
  }
}
----- END server/requireAuth.js -----

STEP 2B.4 — Apply requireAuth to your /api routes
Find your server entry file (common names):
- server.js
- index.js
- app.js

Find where routes are defined, and do:

----- EXAMPLE (Express) -----
import { requireAuth } from "./server/requireAuth.js"; // adjust path

app.get("/api/clover/status/:providerId", requireAuth, async (req, res) => {
  // req.user is now available
  res.json({ ok: true });
});

app.get("/api/pos/connections/:providerId", requireAuth, async (req, res) => {
  res.json({ ok: true });
});
----- END EXAMPLE -----

STEP 2B.5 — Confirm the header is actually arriving
TEMP debug (remove after):
  console.log("AUTH HEADER:", req.headers.authorization);

If it prints undefined, your frontend isn’t sending it OR something is stripping it.

------------------------------------------------------------
2C) Verify on the browser side (must-do check)
------------------------------------------------------------
Open DevTools -> Network -> click the /api/clover/status request
- Request Headers MUST include:
  Authorization: Bearer eyJ...

If missing:
- Your apiFetch isn’t being used
- Or session is null (user not logged in)
- Or import path is broken

============================================================
3) FIX: Supabase REST 404 / 400 / 406 errors
============================================================
You have:
- /rest/v1/reviews ... 404
- /rest/v1/subscriptions ... 404
- /rest/v1/profiles ... 400
- /rest/v1/emergency_requests ... 406

------------------------------------------------------------
3A) 404 Not Found on reviews/subscriptions
------------------------------------------------------------
This usually means:
- table doesn’t exist
- table is not in exposed schema (usually public)
- wrong table name used in code

STEP 3A.1 — Check tables exist
Supabase Dashboard -> Table Editor:
- Confirm tables exist:
  reviews
  subscriptions

If they DO NOT exist:
- Either create tables
- OR remove/replace code that queries them

STEP 3A.2 — Check exposed schema
Supabase Dashboard -> Settings -> API
- Confirm "Exposed schemas" includes the schema your tables are in (usually public)

------------------------------------------------------------
3B) 400 Bad Request on profiles
------------------------------------------------------------
This is almost always a bad column name or malformed select.

STEP 3B.1 — Find the profiles query in Replit
Search: from('profiles')

Temporarily simplify to:
  .select("id, created_at")
If that works, add fields back one-by-one until it breaks.
The field that breaks does not exist (or has different spelling).

------------------------------------------------------------
3C) 406 Not Acceptable on emergency_requests status=in.(...)
------------------------------------------------------------
Common causes:
- column isn’t actually named status
- enum values don’t match exactly
- values are wrong case/spelling

STEP 3C.1 — Find the query
Search: emergency_requests
Search: in.(accepted
Search: status=in

STEP 3C.2 — Temporary test
Remove filters and confirm you can fetch:
  .from("emergency_requests").select("*").limit(25)

Then re-add ONE filter:
  .eq("status", "accepted")

If that fails, your status column/value is wrong.
Check the real column name + allowed values in Supabase Table Editor.

============================================================
4) OPTIONAL: CSP warnings about jsDelivr *.map files
============================================================
You may see:
Blocked by CSP: connect-src ... cdn.jsdelivr.net ... .js.map

This is usually not fatal — it’s source maps.
Best fix in production: remove sourceMappingURL lines from vendor files OR self-host the .map files.
Quick fix: allow cdn.jsdelivr.net in CSP connect-src (and possibly script-src if loading JS from it).

Where to change CSP depends on your host:
- Express: set header in server middleware
- Netlify/Vercel: set headers in config

============================================================
5) RESTART + VALIDATE
============================================================
After changes:
1) Restart server (Stop/Run in Replit)
2) Hard refresh browser (Cmd+Shift+R / Ctrl+Shift+R)
3) Confirm:
- PGRST201 is gone
- /api/clover/status and /api/pos/connections are not 401
- reviews/subscriptions are not 404 (or no longer called)
- profiles isn’t 400
- emergency_requests isn’t 406

============================================================
6) COMMON GOTCHAS (READ THIS IF YOU GET STUCK)
============================================================
- If session is null in browser: user isn’t logged into Supabase on that page.
- Never use SERVICE_ROLE_KEY in frontend. Ever.
- If Authorization header missing in Network:
  you didn’t replace fetch() calls or import path is wrong.
- If backend still says 401 with header present:
  your verify logic isn’t running on that route, or token parsing is wrong.

============================================================
END
============================================================
